/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level façade for compiling Solidity sources with a pre-selected solc version. */
export declare class Compiler {
  /**
   * Download and cache the specified solc release via Foundry's SVM backend.
   *
   * Returns a Bun-friendly `AsyncTask` that resolves when the toolchain is
   * ready. If the release is already cached, the task resolves immediately.
   * Parsing errors and installation failures surface as JavaScript exceptions.
   */
  static installSolcVersion(version: string): Promise<unknown>
  /**
   * Determine whether a specific solc release is already present in the local SVM cache.
   *
   * This helper never triggers downloads; it simply probes the cache, making it
   * suitable for test suites to fail fast when prerequisites are missing.
   */
  static isSolcVersionInstalled(version: string): boolean
  /**
   * Construct a compiler bound to a solc version and default compiler settings.
   *
   * Passing `solcVersion` is optional – when omitted, the default
   * `DEFAULT_SOLC_VERSION` is enforced. The constructor validates that the
   * requested version is already present; callers should invoke
   * `installSolcVersion` ahead of time. Optional `settings` are parsed exactly
   * once and cached for subsequent compilations.
   */
  constructor(options?: CompilerOptions | undefined)
  /**
   * Spawn a new `Shadow` helper that shares this compiler's solc defaults.
   *
   * The returned instance inherits the compiler's configured solc version and
   * settings unless overridden via `options`. Callers can then stitch shadow
   * fragments into either raw source (via `stitchIntoSource`) or existing ASTs.
   */
  createShadow(source: string, options?: ShadowOptions | undefined): Shadow
  /**
   * Compile an in-memory Solidity source file using the configured solc version.
   *
   * - `source` is the Solidity text to compile.
   * - `fileName` controls the virtual file name used for diagnostics (defaults to `Contract.sol`).
   * - `options` allows per-call overrides that merge on top of the constructor defaults.
   *
   * The return value mirrors Foundry's standard JSON output and includes ABI,
   * bytecode, deployed bytecode and any solc diagnostics.
   */
  compileSource(source: string, fileName?: string | undefined, options?: CompilerOptions | undefined): CompileOutput
}

/** Convenience API for deriving AST fragments and stitching them into existing Solidity code. */
export declare class Shadow {
  /**
   * Create a shadow instance with a Solidity fragment that will be injected later.
   *
   * Optional `options` let callers pin the solc version used for parsing. Any
   * provided solver settings are sanitised so the parser always runs with
   * `stopAfter = "parsing"` and AST-only output.
   */
  constructor(source: string, options?: ShadowOptions | undefined)
  /**
   * Parse + stitch the shadow fragment into Solidity source text.
   *
   * - `targetSource` is the Solidity code whose AST will be expanded.
   * - `sourceName` controls diagnostic file names (defaults to `Contract.sol`).
   * - `targetContractName` selects a specific contract; when omitted the last
   *   contract in the file is used.
   * - `options` offer per-call overrides for the solc version/settings.
   *
   * Returns a fully analysed AST (`SourceUnit`) as a plain JS object following Foundry's typings.
   */
  stitchIntoSource(targetSource: string, sourceName?: string | undefined, targetContractName?: string | undefined, options?: ShadowOptions | undefined): import('./ast-types').SourceUnit
  /**
   * Stitch the fragment into an already parsed AST.
   *
   * Accepts any Foundry-style AST object (for example, one produced by
   * `Shadow.stitchIntoSource` or captured from fixtures). Returns a fresh AST
   * value with the injected nodes while leaving the input object untouched.
   */
  stitchIntoAst(targetAst: import('./ast-types').SourceUnit, targetContractName?: string | undefined, sourceName?: string | undefined, options?: ShadowOptions | undefined): import('./ast-types').SourceUnit
}

export declare class SolidityProject {
  /** Create a new project from a root path using Hardhat layout */
  static fromHardhatRoot(rootPath: string): SolidityProject
  /** Create a new project from a root path using Dapptools layout */
  static fromDapptoolsRoot(rootPath: string): SolidityProject
  /** Compile all contracts in the project */
  compile(): CompileOutput
  /** Compile a single file */
  compileFile(filePath: string): CompileOutput
  /** Compile multiple files */
  compileFiles(filePaths: Array<string>): CompileOutput
  /** Find the path of a contract by its name */
  findContractPath(contractName: string): string
  /** Get all source files in the project */
  getSources(): Array<string>
}

export declare class SolidityProjectBuilder {
  /** Create a new project builder */
  constructor()
  /** Set the project paths using hardhat layout */
  hardhatPaths(rootPath: string): void
  /** Set the project paths using dapptools layout */
  dapptoolsPaths(rootPath: string): void
  /** Enable ephemeral mode (disable caching) */
  ephemeral(): this
  /** Set cached mode */
  setCached(cached: boolean): this
  /** Enable offline mode */
  offline(): this
  /** Set offline mode */
  setOffline(offline: boolean): this
  /** Disable writing artifacts to disk */
  noArtifacts(): this
  /** Set whether to write artifacts */
  setNoArtifacts(noArtifacts: boolean): this
  /** Set the number of parallel solc jobs */
  solcJobs(jobs: number): this
  /** Limit to single solc job */
  singleSolcJobs(): this
  /** Build the project */
  build(): SolidityProject
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

export interface CompileOutput {
  artifacts: Array<ContractArtifact>
  errors: Array<CompilerError>
  hasCompilerErrors: boolean
}

export interface CompilerError {
  message: string
  severity: string
  sourceLocation?: SourceLocation
}

/**r" Shared solc configuration accepted by compiler entry points. */
export interface CompilerOptions {
  solcVersion?: string | undefined
  settings?: import('./index').CompilerSettings | undefined
}

/**
 * Full compiler settings accepted by Foundry's solc wrapper.
 *
 * This struct mirrors [`foundry_compilers::artifacts::Settings`] and the nested
 * configuration types, but it is shaped for ergonomic consumption from
 * JavaScript. All fields are optional so callers can provide partial objects;
 * omitted values fall back to solc's defaults when converted back into the
 * Foundry representation.
 */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: OptimizerSettings
  modelChecker?: ModelCheckerSettings
  metadata?: SettingsMetadata
  outputSelection?: import('./solc-types').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: DebuggingSettings
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractArtifact {
  contractName: string
  abi?: string
  bytecode?: string
  deployedBytecode?: string
}

export declare export declare function createCurrentDapptoolsPaths(): ProjectPaths

export declare export declare function createCurrentHardhatPaths(): ProjectPaths

export declare export declare function createDapptoolsPaths(rootPath: string): ProjectPaths

export declare export declare function createHardhatPaths(rootPath: string): ProjectPaths

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Homestead = 'Homestead',
  TangerineWhistle = 'TangerineWhistle',
  SpuriousDragon = 'SpuriousDragon',
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun'
}

export declare export declare function findArtifactsDir(rootPath: string): string

export declare export declare function findLibs(rootPath: string): Array<string>

export declare export declare function findSourceDir(rootPath: string): string

export declare const enum ModelCheckerEngine {
  Default = 'Default',
  All = 'All',
  Bmc = 'Bmc',
  Chc = 'Chc'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Cvc4 = 'Cvc4',
  Eld = 'Eld',
  Smtlib2 = 'Smtlib2',
  Z3 = 'Z3'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Underflow = 'Underflow',
  Overflow = 'Overflow',
  DivByZero = 'DivByZero',
  ConstantCondition = 'ConstantCondition',
  PopEmptyArray = 'PopEmptyArray',
  OutOfBounds = 'OutOfBounds',
  Balance = 'Balance'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: YulDetails
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: OptimizerDetails
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

/**r" Mirror of `CompilerOptions` for the shadow APIs. */
export interface ShadowOptions {
  solcVersion?: string | undefined
  settings?: import('./index').CompilerSettings | undefined
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}
