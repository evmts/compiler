/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Shadow - Parse and stitch Solidity code fragments into contract ASTs
 *
 * Shadow enables parsing incomplete Solidity code (functions, variables, etc.)
 * and stitching them into existing contracts without requiring semantic validity
 * upfront. Demonstrates that Solidity's parser performs pure syntax analysis,
 * allowing AST manipulation before semantic validation.
 */
export declare class Shadow {
  /** Initialize a new Shadow with a source fragment (function, variable, etc.) */
  constructor(source: string)
  /**
   * Stitch shadow nodes into an existing contract's source code
   * Convenience wrapper that parses the source first, then stitches ASTs
   * Returns the fully analyzed AST as a typed object
   *
   * Parameters:
   *   - target_source: The Solidity source code
   *   - source_name: Optional source file name (defaults to "Contract.sol")
   *   - target_contract_name: Optional contract name (defaults to last contract)
   */
  stitchIntoSource(targetSource: string, sourceName?: string | undefined | null, targetContractName?: string | undefined | null): import('./foundry-types').SourceUnit
  /**
   * Stitch shadow nodes into an existing contract's AST
   * Returns fully analyzed AST object
   *
   * Parameters:
   *   - target_ast: The target AST as object
   *   - target_contract_name: Optional contract name (defaults to last contract)
   *   - source_name: Optional source file name (defaults to "Contract.sol")
   */
  stitchIntoAst(targetAst: unknown, targetContractName?: string | undefined | null, sourceName?: string | undefined | null): import('./foundry-types').SourceUnit
  /**
   * Parse Solidity source code and return the strongly typed SourceUnit AST
   * that foundry-compilers exposes as a plain JavaScript object. The returned
   * value preserves the original shape and TypeScript bindings are patched via
   * `foundry-types.ts`.
   */
  static parseSourceAst(source: string, fileName?: string | undefined | null): import('./foundry-types').SourceUnit
}

export declare class SolidityProject {
  /** Create a new project from a root path using Hardhat layout */
  static fromHardhatRoot(rootPath: string): SolidityProject
  /** Create a new project from a root path using Dapptools layout */
  static fromDapptoolsRoot(rootPath: string): SolidityProject
  /** Compile all contracts in the project */
  compile(): CompileOutput
  /** Compile a single file */
  compileFile(filePath: string): CompileOutput
  /** Compile multiple files */
  compileFiles(filePaths: Array<string>): CompileOutput
  /** Find the path of a contract by its name */
  findContractPath(contractName: string): string
  /** Get all source files in the project */
  getSources(): Array<string>
}

export declare class SolidityProjectBuilder {
  /** Create a new project builder */
  constructor()
  /** Set the project paths using hardhat layout */
  hardhatPaths(rootPath: string): void
  /** Set the project paths using dapptools layout */
  dapptoolsPaths(rootPath: string): void
  /** Enable ephemeral mode (disable caching) */
  ephemeral(): this
  /** Set cached mode */
  setCached(cached: boolean): this
  /** Enable offline mode */
  offline(): this
  /** Set offline mode */
  setOffline(offline: boolean): this
  /** Disable writing artifacts to disk */
  noArtifacts(): this
  /** Set whether to write artifacts */
  setNoArtifacts(noArtifacts: boolean): this
  /** Set the number of parallel solc jobs */
  solcJobs(jobs: number): this
  /** Limit to single solc job */
  singleSolcJobs(): this
  /** Build the project */
  build(): SolidityProject
}

export interface CompileOutput {
  artifacts: Array<ContractArtifact>
  errors: Array<CompilerError>
  hasCompilerErrors: boolean
}

export interface CompilerError {
  message: string
  severity: string
  sourceLocation?: SourceLocation
}

export interface ContractArtifact {
  contractName: string
  abi?: string
  bytecode?: string
  deployedBytecode?: string
}

export declare export declare function createCurrentDapptoolsPaths(): ProjectPaths

export declare export declare function createCurrentHardhatPaths(): ProjectPaths

export declare export declare function createDapptoolsPaths(rootPath: string): ProjectPaths

export declare export declare function createHardhatPaths(rootPath: string): ProjectPaths

export declare export declare function findArtifactsDir(rootPath: string): string

export declare export declare function findLibs(rootPath: string): Array<string>

export declare export declare function findSourceDir(rootPath: string): string

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export declare export declare function sum(a: number, b: number): number
