/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level helper for manipulating Solidity ASTs prior to recompilation. */
export declare class Ast {
  /**
   * Create a new AST helper. Providing `instrumentedContract`
   * establishes the instrumented contract targeted by subsequent operations.
   */
  constructor(options?: AstOptions | undefined)
  /**
   * Parse Solidity source into an AST using the configured solc version.
   * When no `instrumentedContract` is provided, later operations apply to all
   * contracts in the file.
   */
  fromSource(target: string | object, options?: AstOptions | undefined): this
  /**
   * Parse an AST fragment from source text or inject a pre-parsed AST fragment
   * into the targeted contract.
   */
  injectShadow(fragment: string | object, options?: AstOptions | undefined): this
  /**
   * Promote private/internal state variables to public visibility. Omitting
   * `instrumentedContract` applies the change to all contracts.
   */
  exposeInternalVariables(options?: AstOptions | undefined): this
  /**
   * Promote private/internal functions to public visibility. Omitting
   * `instrumentedContract` applies the change to all contracts.
   */
  exposeInternalFunctions(options?: AstOptions | undefined): this
  /** Get the current intrumented AST. */
  ast(): import('./ast-types').SourceUnit
}

export declare class Compiler {
  static installSolcVersion(version: string): Promise<unknown>
  static isSolcVersionInstalled(version: string): boolean
  constructor(options?: CompilerConfig | undefined)
  static fromFoundryRoot(root: string, options?: CompilerConfig | undefined): Compiler
  static fromHardhatRoot(root: string, options?: CompilerConfig | undefined): Compiler
  compileSource(target: string | object, options?: CompilerConfig | undefined): CompileOutput
  compileSources(sources: Record<string, string | object>, options?: CompilerConfig | undefined): CompileOutput
  compileFiles(paths: string[], options?: CompilerConfig | undefined): CompileOutput
  compileProject(options?: CompilerConfig | undefined): CompileOutput
  compileContract(contractName: string, options?: CompilerConfig | undefined): CompileOutput
}

export interface AstOptions {
  solcVersion?: string | undefined
  solcLanguage?: import('./index').SolcLanguage | undefined
  settings?: import('./index').CompilerSettings | undefined
  instrumentedContract?: string | undefined
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

export interface CompileOutput {
  artifacts: Array<ContractArtifact>
  errors: Array<CompilerError>
  hasCompilerErrors: boolean
}

export interface CompilerConfig {
  solcVersion?: string | undefined
  solcLanguage?: import('./index').SolcLanguage | undefined
  solcSettings?: import('./index').CompilerSettings | undefined
  cacheEnabled?: boolean | undefined
  baseDir?: string | undefined
  offlineMode?: boolean | undefined
  noArtifacts?: boolean | undefined
  buildInfoEnabled?: boolean | undefined
  slashPaths?: boolean | undefined
  solcJobs?: number | undefined
  sparseOutput?: boolean | undefined
  allowPaths?: string[] | undefined
  includePaths?: string[] | undefined
  libraryPaths?: string[] | undefined
  remappings?: string[] | undefined
  ignoredErrorCodes?: number[] | undefined
  ignoredPaths?: string[] | undefined
  compilerSeverity?: string | undefined
}

export interface CompilerError {
  message: string
  severity: string
  sourceLocation?: SourceLocation
}

/** Full compiler settings accepted by Foundry's solc wrapper. */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: OptimizerSettings
  modelChecker?: ModelCheckerSettings
  metadata?: SettingsMetadata
  outputSelection?: import('./solc-types').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: DebuggingSettings
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractArtifact {
  contractName: string
  abi?: unknown | undefined
  abiJson?: string
  bytecode?: ContractBytecode
  deployedBytecode?: ContractBytecode
}

export interface ContractBytecode {
  hex?: string
  bytes?: Uint8Array | undefined
}

export declare export declare function createCurrentDapptoolsPaths(): ProjectPaths

export declare export declare function createCurrentHardhatPaths(): ProjectPaths

export declare export declare function createDapptoolsPaths(rootPath: string): ProjectPaths

export declare export declare function createHardhatPaths(rootPath: string): ProjectPaths

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun',
  Prague = 'Prague'
}

export declare export declare function findArtifactsDir(rootPath: string): string

export declare export declare function findLibs(rootPath: string): Array<string>

export declare export declare function findSourceDir(rootPath: string): string

export declare const enum ModelCheckerEngine {
  Bmc = 'Bmc',
  None = 'None'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export declare const enum ModelCheckerInvariantKind {
  Reentrancy = 'Reentrancy',
  Contract = 'Contract'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Z3 = 'Z3',
  Eld = 'Eld',
  Cvc4 = 'Cvc4',
  EldStrict = 'EldStrict'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Contract = 'Contract',
  External = 'External',
  Public = 'Public'
}

export declare const enum ModelCheckerTargetType {
  RecursiveDepth = 'RecursiveDepth',
  BoundedLoop = 'BoundedLoop'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: YulDetails
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: OptimizerDetails
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

export declare const enum SolcLanguage {
  Solidity = 'Solidity',
  Yul = 'Yul'
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}
