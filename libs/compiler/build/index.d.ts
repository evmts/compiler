/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level helper for manipulating Solidity ASTs prior to recompilation. */
export declare class Ast {
  /**
   * Create a new AST helper. Providing `instrumentedContract`
   * establishes the instrumented contract targeted by subsequent operations.
   */
  constructor(options?: AstOptions | undefined)
  /**
   * Parse Solidity source into an AST using the configured solc version.
   * When no `instrumentedContract` is provided, later operations apply to all
   * contracts in the file.
   */
  fromSource(target: string | object, options?: AstOptions | undefined): this
  /**
   * Parse an AST fragment from source text or inject a pre-parsed AST fragment
   * into the targeted contract.
   */
  injectShadow(fragment: string | object, options?: AstOptions | undefined): this
  /**
   * Promote private/internal state variables to public visibility. Omitting
   * `instrumentedContract` applies the change to all contracts.
   */
  exposeInternalVariables(options?: AstOptions | undefined): this
  /**
   * Promote private/internal functions to public visibility. Omitting
   * `instrumentedContract` applies the change to all contracts.
   */
  exposeInternalFunctions(options?: AstOptions | undefined): this
  /** Get the current intrumented AST. */
  ast(): import('./ast-types').SourceUnit
}

/** High-level façade for compiling Solidity sources with a pre-selected solc version. */
export declare class Compiler {
  /**
   * Download and cache the specified solc release via Foundry's SVM backend.
   *
   * Returns a Bun-friendly `AsyncTask` that resolves when the toolchain is
   * ready. If the release is already cached, the task resolves immediately.
   * Parsing errors and installation failures surface as JavaScript exceptions.
   */
  static installSolcVersion(version: string): Promise<unknown>
  /**
   * Determine whether a specific solc release is already present in the local SVM cache.
   *
   * This helper never triggers downloads; it simply probes the cache, making it
   * suitable for test suites to fail fast when prerequisites are missing.
   */
  static isSolcVersionInstalled(version: string): boolean
  /**
   * Construct a compiler bound to a solc version and default compiler settings.
   *
   * Passing `solcVersion` is optional – when omitted, the default
   * `DEFAULT_SOLC_VERSION` is enforced. The constructor validates that the
   * requested version is already present; callers should invoke
   * `installSolcVersion` ahead of time. Optional `settings` are parsed exactly
   * once and cached for subsequent compilations.
   */
  constructor(options?: CompilerOptions | undefined)
  /**
   * Compile Solidity/Yul source text or a pre-existing AST using the configured solc version.
   *
   * - When `target` is a string, the optional `solcLanguage` controls whether it is treated as
   *   Solidity (default) or Yul.
   * - Passing an object is interpreted as a Solidity AST and compiled directly.
   * - `options` allows per-call overrides that merge on top of the constructor defaults.
   *
   * The return value mirrors Foundry's standard JSON output and includes ABI,
   * bytecode, deployed bytecode and any solc diagnostics.
   */
  compileSource(target: string | object, options?: CompilerOptions | undefined): CompileOutput
  /** Compile multiple sources supplied as a path keyed lookup. */
  compileSources(sources: Record<string, string | object>, options?: CompilerOptions | undefined): CompileOutput
  /** Compile sources from on-disk files identified by their paths. */
  compileFiles(paths: string[], options?: CompilerOptions | undefined): CompileOutput
}

export declare class SolidityProject {
  /** Create a new project from a root path using Hardhat layout */
  static fromHardhatRoot(rootPath: string): SolidityProject
  /** Create a new project from a root path using Dapptools layout */
  static fromDapptoolsRoot(rootPath: string): SolidityProject
  /** Compile all contracts in the project */
  compile(): CompileOutput
  /** Compile a single file */
  compileFile(filePath: string): CompileOutput
  /** Compile multiple files */
  compileFiles(filePaths: Array<string>): CompileOutput
  /** Find the path of a contract by its name */
  findContractPath(contractName: string): string
  /** Get all source files in the project */
  getSources(): Array<string>
}

export declare class SolidityProjectBuilder {
  /** Create a new project builder */
  constructor()
  /** Set the project paths using hardhat layout */
  hardhatPaths(rootPath: string): void
  /** Set the project paths using dapptools layout */
  dapptoolsPaths(rootPath: string): void
  /** Enable ephemeral mode (disable caching) */
  ephemeral(): this
  /** Set cached mode */
  setCached(cached: boolean): this
  /** Enable offline mode */
  offline(): this
  /** Set offline mode */
  setOffline(offline: boolean): this
  /** Disable writing artifacts to disk */
  noArtifacts(): this
  /** Set whether to write artifacts */
  setNoArtifacts(noArtifacts: boolean): this
  /** Set the number of parallel solc jobs */
  solcJobs(jobs: number): this
  /** Limit to single solc job */
  singleSolcJobs(): this
  /** Build the project */
  build(): SolidityProject
}

export interface AstOptions {
  solcVersion?: string | undefined
  solcLanguage?: import('./index').SolcLanguage | undefined
  settings?: import('./index').CompilerSettings | undefined
  instrumentedContract?: string | undefined
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

export interface CompileOutput {
  artifacts: Array<ContractArtifact>
  errors: Array<CompilerError>
  hasCompilerErrors: boolean
}

export interface CompilerError {
  message: string
  severity: string
  sourceLocation?: SourceLocation
}

/**r" Shared solc configuration accepted by compiler entry points. */
export interface CompilerOptions {
  solcVersion?: string | undefined
  solcLanguage?: import('./index').SolcLanguage | undefined
  settings?: import('./index').CompilerSettings | undefined
}

/**
 * Full compiler settings accepted by Foundry's solc wrapper.
 *
 * This struct mirrors [`foundry_compilers::artifacts::Settings`] and the nested
 * configuration types, but it is shaped for ergonomic consumption from
 * JavaScript. All fields are optional so callers can provide partial objects;
 * omitted values fall back to solc's defaults when converted back into the
 * Foundry representation.
 */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: OptimizerSettings
  modelChecker?: ModelCheckerSettings
  metadata?: SettingsMetadata
  outputSelection?: import('./solc-types').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: DebuggingSettings
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractArtifact {
  contractName: string
  abi?: string
  bytecode?: string
  deployedBytecode?: string
}

export declare export declare function createCurrentDapptoolsPaths(): ProjectPaths

export declare export declare function createCurrentHardhatPaths(): ProjectPaths

export declare export declare function createDapptoolsPaths(rootPath: string): ProjectPaths

export declare export declare function createHardhatPaths(rootPath: string): ProjectPaths

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Homestead = 'Homestead',
  TangerineWhistle = 'TangerineWhistle',
  SpuriousDragon = 'SpuriousDragon',
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun'
}

export declare export declare function findArtifactsDir(rootPath: string): string

export declare export declare function findLibs(rootPath: string): Array<string>

export declare export declare function findSourceDir(rootPath: string): string

export declare const enum ModelCheckerEngine {
  Default = 'Default',
  All = 'All',
  Bmc = 'Bmc',
  Chc = 'Chc'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Cvc4 = 'Cvc4',
  Eld = 'Eld',
  Smtlib2 = 'Smtlib2',
  Z3 = 'Z3'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Underflow = 'Underflow',
  Overflow = 'Overflow',
  DivByZero = 'DivByZero',
  ConstantCondition = 'ConstantCondition',
  PopEmptyArray = 'PopEmptyArray',
  OutOfBounds = 'OutOfBounds',
  Balance = 'Balance'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: YulDetails
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: OptimizerDetails
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

export declare const enum SolcLanguage {
  Solidity = 'Solidity',
  Yul = 'Yul'
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}
