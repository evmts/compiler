/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level helper for manipulating Solidity ASTs prior to recompilation. */
export declare class Ast {
  /**
   * Create a new AST helper. Providing `instrumentedContract` establishes the instrumented
   * contract targeted by subsequent operations.
   */
  constructor(options?: AstConfigOptions | undefined)
  /**
   * Parse Solidity source into an AST using the configured solc version. When no
   * `instrumentedContract` is provided, later operations apply to all contracts in the file.
   */
  fromSource(target: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Parse an AST fragment from source text or inject a pre-parsed AST fragment into the targeted
   * contract.
   */
  injectShadow(fragment: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal state variables to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalVariables(options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal functions to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalFunctions(options?: AstConfigOptions | undefined): this
  /**
   * Compile the current AST to ensure it represents a valid contract and refresh its references.
   * This is optionalâ€”`ast()` already returns the parsed tree you can work with directly.
   */
  validate(options?: AstConfigOptions | undefined): this
  /** Get the current instrumented AST. */
  ast(): import('./solc-ast').SourceUnit
}
export type JsAst = Ast

export declare class Compiler {
  static installSolcVersion(version: string): Promise<unknown>
  static isSolcVersionInstalled(version: string): boolean
  constructor(options?: CompilerConfigOptions | undefined)
  static fromFoundryRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromHardhatRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  compileSource(target: string | object, options?: CompilerConfigOptions | undefined): CompileOutput
  compileSources(sources: Record<string, string | object>, options?: CompilerConfigOptions | undefined): CompileOutput
  compileFiles(paths: string[], options?: CompilerConfigOptions | undefined): CompileOutput
  compileProject(options?: CompilerConfigOptions | undefined): CompileOutput
  compileContract(contractName: string, options?: CompilerConfigOptions | undefined): CompileOutput
  getPaths(): ProjectPaths
}
export type JsCompiler = Compiler

export interface AstConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: import('./index').CompilerSettings | undefined
  instrumentedContract?: string | undefined
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

export interface CompileOutput {
  artifacts: Array<ContractArtifact>
  errors: Array<CompilerError>
  hasCompilerErrors: boolean
}

/** JavaScript-facing configuration captured through N-API bindings. */
export interface CompilerConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: import('./index').CompilerSettings | undefined
  cacheEnabled?: boolean | undefined
  offlineMode?: boolean | undefined
  noArtifacts?: boolean | undefined
  buildInfoEnabled?: boolean | undefined
  slashPaths?: boolean | undefined
  solcJobs?: number | undefined
  sparseOutput?: boolean | undefined
  allowPaths?: string[] | undefined
  includePaths?: string[] | undefined
  libraryPaths?: string[] | undefined
  remappings?: string[] | undefined
  ignoredErrorCodes?: number[] | undefined
  ignoredPaths?: string[] | undefined
  compilerSeverity?: string | undefined
}

export interface CompilerError {
  message: string
  severity: string
  sourceLocation?: SourceLocation
}

/** JavaScript-facing wrappers mirroring the option structs. */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: import('./index').OptimizerSettings | undefined
  modelChecker?: import('./index').ModelCheckerSettings | undefined
  metadata?: import('./index').SettingsMetadata | undefined
  outputSelection?: import('./solc-settings').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: import('./index').DebuggingSettings | undefined
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractArtifact {
  contractName: string
  abi?: unknown | undefined
  abiJson?: string
  bytecode?: ContractBytecode
  deployedBytecode?: ContractBytecode
}

export interface ContractBytecode {
  hex?: string
  bytes?: Uint8Array | undefined
}

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun',
  Prague = 'Prague'
}

export declare const enum ModelCheckerEngine {
  Bmc = 'Bmc',
  None = 'None'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export declare const enum ModelCheckerInvariantKind {
  Reentrancy = 'Reentrancy',
  Contract = 'Contract'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Chc = 'Chc',
  Eld = 'Eld',
  Bmc = 'Bmc',
  AllZ3 = 'AllZ3',
  Cvc4 = 'Cvc4'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Require = 'Require'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: import('./index').YulDetails | undefined
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: import('./index').OptimizerDetails | undefined
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  buildInfos: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
  includePaths: Array<string>
  allowedPaths: Array<string>
  virtualSources?: string
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

export declare const enum SolcLanguage {
  Solidity = 'Solidity',
  Yul = 'Yul'
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}
