/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level helper for manipulating Solidity ASTs prior to recompilation. */
export declare class Ast {
  /**
   * Create a new AST helper. Providing `instrumentedContract` establishes the instrumented
   * contract targeted by subsequent operations.
   */
  constructor(options?: AstConfigOptions | undefined)
  /**
   * Parse Solidity source into an AST using the configured solc version. When no
   * `instrumentedContract` is provided, later operations apply to all contracts in the file.
   */
  fromSource(target: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Parse an AST fragment from source text or inject a pre-parsed AST fragment into the targeted
   * contract.
   */
  injectShadow(fragment: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal state variables to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalVariables(options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal functions to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalFunctions(options?: AstConfigOptions | undefined): this
  /**
   * Compile the current AST to ensure it represents a valid contract and refresh its references.
   * This is optionalâ€”`ast()` already returns the parsed tree you can work with directly.
   */
  validate(options?: AstConfigOptions | undefined): this
  /** Get the current instrumented AST. */
  ast(): import('./solc-ast').SourceUnit
}
export type JsAst = Ast
export declare class CompileOutput<
  THasErrors extends boolean = boolean,
  TSourcePaths extends readonly string[] | undefined = string[] | undefined
> {
  constructor();
  get artifactsJson(): Record<string, unknown>;
  get artifacts(): ArtifactMap<THasErrors, TSourcePaths>;
  get artifact(): ArtifactValue<THasErrors, TSourcePaths>;
  get errors(): THasErrors extends true
    ? ReadonlyArray<CompilerError>
    : undefined;
  get diagnostics(): Array<CompilerError>;
  hasCompilerErrors(): this is CompileOutput<true, TSourcePaths>;
}

export type JsCompileOutput = CompileOutput

export declare class Compiler {
  static installSolcVersion(version: string): Promise<unknown>
  static isSolcVersionInstalled(version: string): boolean
  constructor(options?: CompilerConfigOptions | undefined)
  static fromFoundryRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromHardhatRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  compileSource(target: string | object, options?: CompilerConfigOptions | undefined): CompileOutput<true, undefined> | CompileOutput<false, undefined>
  compileSources<TSources extends Record<string, string | object> = Record<string, string | object>>(sources: TSources, options?: CompilerConfigOptions | undefined): CompileOutput<true, Extract<keyof TSources, string>[]> | CompileOutput<false, Extract<keyof TSources, string>[]>
  compileFiles<TFilePaths extends readonly string[] = readonly string[]>(paths: TFilePaths, options?: CompilerConfigOptions | undefined): CompileOutput<true, TFilePaths> | CompileOutput<false, TFilePaths>
  compileProject(options?: CompilerConfigOptions | undefined): CompileOutput<true, string[]> | CompileOutput<false, string[]>
  compileContract(contractName: string, options?: CompilerConfigOptions | undefined): CompileOutput<true, undefined> | CompileOutput<false, undefined>
  getPaths(): ProjectPaths
}
export type JsCompiler = Compiler

export declare class Contract {
  constructor(state: ContractState)
static fromSolcContractOutput(name: string, contract: object | string): Contract & { readonly __state?: ContractState }
get name(): string
get address(): `0x${string}` | null | undefined
get creationBytecode(): ContractBytecode | null
get runtimeBytecode(): ContractBytecode | null
get deployedBytecode(): ContractBytecode | null
get abi(): ContractState['abi']
get metadata(): ContractState['metadata']
get userdoc(): ContractState['userdoc']
get devdoc(): ContractState['devdoc']
get storageLayout(): ContractState['storageLayout']
get immutableReferences(): ContractState['immutableReferences']
get methodIdentifiers(): ContractState['methodIdentifiers']
get functionDebugData(): ContractState['functionDebugData']
get gasEstimates(): ContractState['gasEstimates']
get assembly(): string | null
get legacyAssembly(): ContractState['legacyAssembly']
get opcodes(): string | null
get ir(): string | null
get irOptimized(): string | null
get ewasm(): ContractState['ewasm']
get creationSourceMap(): string | null
get extras(): Record<string, unknown>
withAddress<State extends ContractState, NextAddress extends `0x${string}` | null | undefined = `0x${string}` | null | undefined>(this: Contract & { readonly __state?: State }, address?: NextAddress): Contract & { readonly __state?: (State extends ContractState ? (NextAddress extends undefined ? Omit<State, 'address'> & { address?: State['address'] } : Omit<State, 'address'> & { address: Exclude<NextAddress, undefined> }) : never) }
withCreationBytecode<State extends ContractState, NextBytecode extends Buffer | null | undefined = Buffer | null | undefined>(this: Contract & { readonly __state?: State }, bytecode?: NextBytecode): Contract & { readonly __state?: (State extends ContractState ? (NextBytecode extends undefined ? Omit<State, 'creationBytecode'> & { creationBytecode?: State['creationBytecode'] } : NextBytecode extends null ? Omit<State, 'creationBytecode'> & { creationBytecode: null } : Omit<State, 'creationBytecode'> & { creationBytecode: ContractBytecode }) : never) }
withRuntimeBytecode<State extends ContractState, NextBytecode extends Buffer | null | undefined = Buffer | null | undefined>(this: Contract & { readonly __state?: State }, bytecode?: NextBytecode): Contract & { readonly __state?: (State extends ContractState ? (NextBytecode extends undefined ? Omit<State, 'runtimeBytecode'> & { runtimeBytecode?: State['runtimeBytecode'] } : NextBytecode extends null ? Omit<State, 'runtimeBytecode'> & { runtimeBytecode: null } : Omit<State, 'runtimeBytecode'> & { runtimeBytecode: ContractBytecode }) : never) }
withDeployedBytecode<State extends ContractState, NextBytecode extends Buffer | null | undefined = Buffer | null | undefined>(this: Contract & { readonly __state?: State }, bytecode?: NextBytecode): Contract & { readonly __state?: (State extends ContractState ? (NextBytecode extends undefined ? Omit<State, 'deployedBytecode'> & { deployedBytecode?: State['deployedBytecode'] } : NextBytecode extends null ? Omit<State, 'deployedBytecode'> & { deployedBytecode: null } : Omit<State, 'deployedBytecode'> & { deployedBytecode: ContractBytecode }) : never) }
withExtra<State extends ContractState, Key extends string, Value = unknown>(this: Contract & { readonly __state?: State }, key: Key, value: Value): Contract & { readonly __state?: (State extends ContractState ? Omit<State, 'extras'> & { extras: (State['extras'] extends Record<string, unknown> ? State['extras'] : {}) & Record<Key, Value> } : never) }
toJson<State extends ContractState>(this: Contract & { readonly __state?: State }): State
}
export type JsContract = Contract
export declare class SourceArtifacts<TPath extends string = string> {
  constructor()
  get sourcePath(): TPath | null
  get sourceId(): number | null
  get solcVersion(): string | null
  get astJson(): import('./solc-ast').SourceUnit | undefined
  get ast(): Ast | undefined
  get contracts(): Record<string, Contract>
}

export type JsSourceArtifacts = SourceArtifacts

export interface AstConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: CompilerSettings | undefined
  instrumentedContract?: string | undefined
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

/** JavaScript-facing configuration captured through N-API bindings. */
export interface CompilerConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: CompilerSettings | undefined
  cacheEnabled?: boolean | undefined
  offlineMode?: boolean | undefined
  noArtifacts?: boolean | undefined
  buildInfoEnabled?: boolean | undefined
  slashPaths?: boolean | undefined
  solcJobs?: number | undefined
  sparseOutput?: boolean | undefined
  allowPaths?: string[] | undefined
  includePaths?: string[] | undefined
  libraryPaths?: string[] | undefined
  remappings?: string[] | undefined
  ignoredErrorCodes?: number[] | undefined
  ignoredPaths?: string[] | undefined
  compilerSeverity?: string | undefined
}

export interface CompilerError {
  message: string
  formattedMessage?: string
  component: string
  severity: SeverityLevel
  errorType: string
  errorCode?: number
  sourceLocation?: SourceLocation
  secondarySourceLocations?: Array<SecondarySourceLocation>
}

/** JavaScript-facing wrappers mirroring the option structs. */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: OptimizerSettings | undefined
  modelChecker?: ModelCheckerSettings | undefined
  metadata?: SettingsMetadata | undefined
  outputSelection?: import('./solc-settings').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: DebuggingSettings | undefined
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractBytecode {
  hex?: `0x${string}` | null | undefined
  bytes?: Uint8Array | null | undefined
}

export interface ContractState {
  name: string
  address?: `0x${string}` | null | undefined
  abi?: unknown | null | undefined
  sourcePath?: string
  sourceId?: number
  creationBytecode?: ContractBytecode | null | undefined
  runtimeBytecode?: ContractBytecode | null | undefined
  deployedBytecode?: ContractBytecode | null | undefined
  metadata?: string | Record<string, unknown> | null | undefined
  userdoc?: Record<string, unknown> | null | undefined
  devdoc?: Record<string, unknown> | null | undefined
  storageLayout?: import('./solc-storage-layout').StorageLayout | null | undefined
  immutableReferences?: Record<string, { start: number; length: number }[]> | null | undefined
  methodIdentifiers?: Record<string, `0x${string}`> | null | undefined
  functionDebugData?: Record<string, FunctionDebugDataEntry> | null | undefined
  gasEstimates?: GasEstimates | null | undefined
  assembly?: string
  legacyAssembly?: Record<string, unknown> | null | undefined
  opcodes?: string
  ir?: string
  irOptimized?: string
  ewasm?: EwasmOutput | null | undefined
  creationSourceMap?: string | null | undefined
  extras?: Record<string, unknown> | null | undefined
}

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun',
  Prague = 'Prague'
}

export interface EwasmOutput {
  wast?: string | null | undefined
  wasm: string
}

export interface FunctionDebugDataEntry {
  entryPoint?: number | null | undefined
  id?: number | null | undefined
  parameterSlots?: number | null | undefined
  returnSlots?: number | null | undefined
}

export interface GasEstimates {
  creation: GasEstimatesCreation
  external: Record<string, string>
  internal: Record<string, string>
}

export interface GasEstimatesCreation {
  codeDepositCost: string
  executionCost: string
  totalCost: string
}

export interface ImmutableSlot {
  start: number
  length: number
}

export declare const enum ModelCheckerEngine {
  Bmc = 'Bmc',
  None = 'None'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export declare const enum ModelCheckerInvariantKind {
  Reentrancy = 'Reentrancy',
  Contract = 'Contract'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Chc = 'Chc',
  Eld = 'Eld',
  Bmc = 'Bmc',
  AllZ3 = 'AllZ3',
  Cvc4 = 'Cvc4'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Require = 'Require'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: YulDetails | undefined
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: OptimizerDetails | undefined
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  buildInfos: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
  includePaths: Array<string>
  allowedPaths: Array<string>
  virtualSources?: string
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SecondarySourceLocation {
  file?: string
  start?: number
  end?: number
  message?: string
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

export declare const enum SeverityLevel {
  Error = 'Error',
  Warning = 'Warning',
  Info = 'Info'
}

export declare const enum SolcLanguage {
  Solidity = 'Solidity',
  Yul = 'Yul'
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}

type WithPathKey<TPath, TValue> = TValue extends SourceArtifacts<infer _>
  ? SourceArtifacts<Extract<TPath, string>>
  : TValue;

type ReadonlyRecord<K extends PropertyKey, V> = Readonly<
  { [P in K]: WithPathKey<P, V> }
>;

type ReadonlyPartialRecord<K extends PropertyKey, V> = Readonly<
  Partial<{ [P in K]: WithPathKey<P, V> }>
>;

type ArtifactMap<
  THasErrors extends boolean,
  TPaths extends readonly string[] | undefined,
> = TPaths extends readonly string[]
  ? THasErrors extends false
    ? ReadonlyRecord<TPaths[number], SourceArtifacts>
    : ReadonlyPartialRecord<TPaths[number], SourceArtifacts>
  : never;

type ArtifactValue<
  THasErrors extends boolean,
  TPaths extends readonly string[] | undefined,
> = TPaths extends undefined
  ? THasErrors extends false
    ? SourceArtifacts
    : SourceArtifacts | undefined
  : never;

/**
 * Place custom type/interface overrides here. The postbuild-dts script will
 * replace matching declarations in build/index.d.ts after every build.
 */
