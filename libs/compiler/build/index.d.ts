/* auto-generated by NAPI-RS */
/* eslint-disable */
/** High-level helper for manipulating Solidity ASTs prior to recompilation. */
export declare class Ast {
  /**
   * Create a new AST helper. Providing `instrumentedContract` establishes the instrumented
   * contract targeted by subsequent operations.
   */
  constructor(options?: AstConfigOptions | undefined)
  /**
   * Parse Solidity source into an AST using the configured solc version. When no
   * `instrumentedContract` is provided, later operations apply to all contracts in the file.
   */
  fromSource(target: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Parse an AST fragment from source text or inject a pre-parsed AST fragment into the targeted
   * contract.
   */
  injectShadow(fragment: string | object, options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal state variables to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalVariables(options?: AstConfigOptions | undefined): this
  /**
   * Promote private/internal functions to public visibility. Omitting `instrumentedContract`
   * applies the change to all contracts.
   */
  exposeInternalFunctions(options?: AstConfigOptions | undefined): this
  /**
   * Compile the current AST to ensure it represents a valid contract and refresh its references.
   * This is optionalâ€”`ast()` already returns the parsed tree you can work with directly.
   */
  validate(options?: AstConfigOptions | undefined): this
  /** Get the current instrumented AST. */
  ast(): import('./solc-ast').SourceUnit
}
export type JsAst = Ast
export declare class CompileOutput<
  THasErrors extends boolean = boolean,
  TSourcePaths extends readonly string[] | undefined = string[] | undefined
> {
  constructor();
  get artifactsJson(): Record<string, unknown>;
  get artifacts(): ArtifactMap<THasErrors, TSourcePaths>;
  get artifact(): ArtifactValue<THasErrors, TSourcePaths>;
  get errors(): THasErrors extends true
    ? ReadonlyArray<CompilerError>
    : undefined;
  get diagnostics(): Array<CompilerError>;
  hasCompilerErrors(): this is CompileOutput<true, TSourcePaths>;
}

export type JsCompileOutput = CompileOutput

export declare class Compiler {
  static installSolcVersion(version: string): Promise<unknown>
  static isSolcVersionInstalled(version: string): boolean
  constructor(options?: CompilerConfigOptions | undefined)
  static fromFoundryRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromHardhatRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  static fromRoot(root: string, options?: CompilerConfigOptions | undefined): JsCompiler
  compileSource(target: string | object, options?: CompilerConfigOptions | undefined): CompileOutput<true, undefined> | CompileOutput<false, undefined>
  compileSources<TSources extends Record<string, string | object> = Record<string, string | object>>(sources: TSources, options?: CompilerConfigOptions | undefined): CompileOutput<true, Extract<keyof TSources, string>[]> | CompileOutput<false, Extract<keyof TSources, string>[]>
  compileFiles<TFilePaths extends readonly string[] = readonly string[]>(paths: TFilePaths, options?: CompilerConfigOptions | undefined): CompileOutput<true, TFilePaths> | CompileOutput<false, TFilePaths>
  compileProject(options?: CompilerConfigOptions | undefined): CompileOutput<true, string[]> | CompileOutput<false, string[]>
  compileContract(contractName: string, options?: CompilerConfigOptions | undefined): CompileOutput<true, undefined> | CompileOutput<false, undefined>
  getPaths(): ProjectPaths
}
export type JsCompiler = Compiler
export interface Contract<
  Name extends string = string,
  Map extends ContractStateMap = {}
> {
  readonly __state: ContractSnapshot<Name, Map>;
  readonly name: Name;
  readonly address: FieldValue<Map, "address">;
  readonly creationBytecode: FieldValue<Map, "creationBytecode">;
  readonly deployedBytecode: FieldValue<Map, "deployedBytecode">;
  readonly abi: FieldValue<Map, "abi">;
  readonly metadata: FieldValue<Map, "metadata">;
  readonly userdoc: FieldValue<Map, "userdoc">;
  readonly devdoc: FieldValue<Map, "devdoc">;
  readonly storageLayout: FieldValue<Map, "storageLayout">;
  readonly immutableReferences: FieldValue<Map, "immutableReferences">;
  readonly methodIdentifiers: FieldValue<Map, "methodIdentifiers">;
  readonly functionDebugData: FieldValue<Map, "functionDebugData">;
  readonly gasEstimates: FieldValue<Map, "gasEstimates">;
  readonly assembly: FieldValue<Map, "assembly">;
  readonly legacyAssembly: FieldValue<Map, "legacyAssembly">;
  readonly opcodes: FieldValue<Map, "opcodes">;
  readonly ir: FieldValue<Map, "ir">;
  readonly irOptimized: FieldValue<Map, "irOptimized">;
  readonly ewasm: FieldValue<Map, "ewasm">;
  readonly creationSourceMap: FieldValue<Map, "creationSourceMap">;
  withAddress<
    NextAddress extends `0x${string}` | null | undefined =
      | `0x${string}`
      | null
      | undefined
  >(
    address?: NextAddress
  ): Contract<Name, UpdateMap<Map, "address", NextAddress>>;
  withCreationBytecode(): Contract<
    Name,
    UpdateMap<Map, "creationBytecode", undefined>
  >;
  withCreationBytecode(
    bytecode: null
  ): Contract<Name, UpdateMap<Map, "creationBytecode", null>>;
  withCreationBytecode(
    bytecode: Uint8Array | `0x${string}` | string
  ): Contract<Name, UpdateMap<Map, "creationBytecode", ContractBytecode>>;
  withCreationBytecode(
    bytecode?: Uint8Array | `0x${string}` | string | null
  ): Contract<
    Name,
    UpdateMap<Map, "creationBytecode", BytecodeMapValue<typeof bytecode>>
  >;
  withDeployedBytecode(): Contract<
    Name,
    UpdateMap<Map, "deployedBytecode", undefined>
  >;
  withDeployedBytecode(
    bytecode: null
  ): Contract<Name, UpdateMap<Map, "deployedBytecode", null>>;
  withDeployedBytecode(
    bytecode: Uint8Array | `0x${string}` | string
  ): Contract<Name, UpdateMap<Map, "deployedBytecode", ContractBytecode>>;
  withDeployedBytecode(
    bytecode?: Uint8Array | `0x${string}` | string | null
  ): Contract<
    Name,
    UpdateMap<Map, "deployedBytecode", BytecodeMapValue<typeof bytecode>>
  >;
  toJson(): ContractSnapshot<Name, Map>;
}

export type JsContract = Contract
export declare class SourceArtifacts<TPath extends string = string> {
  constructor();
  get sourcePath(): TPath | null;
  get sourceId(): number | null;
  get solcVersion(): string | null;
  get astJson(): import("./solc-ast").SourceUnit | undefined;
  get ast(): Ast | undefined;
  get contracts(): Record<string, Contract>;
}

export type JsSourceArtifacts = SourceArtifacts

export interface AstConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: CompilerSettings | undefined
  instrumentedContract?: string | undefined
}

export declare const enum BytecodeHash {
  Ipfs = 'Ipfs',
  None = 'None',
  Bzzr1 = 'Bzzr1'
}

/** JavaScript-facing configuration captured through N-API bindings. */
export interface CompilerConfigOptions {
  solcVersion?: string | undefined
  solcLanguage?: SolcLanguage
  solcSettings?: CompilerSettings | undefined
  cacheEnabled?: boolean | undefined
  offlineMode?: boolean | undefined
  noArtifacts?: boolean | undefined
  buildInfoEnabled?: boolean | undefined
  slashPaths?: boolean | undefined
  solcJobs?: number | undefined
  sparseOutput?: boolean | undefined
  allowPaths?: string[] | undefined
  includePaths?: string[] | undefined
  libraryPaths?: string[] | undefined
  remappings?: string[] | undefined
  ignoredErrorCodes?: number[] | undefined
  ignoredPaths?: string[] | undefined
  compilerSeverity?: string | undefined
}

export interface CompilerError {
  message: string
  formattedMessage?: string
  component: string
  severity: SeverityLevel
  errorType: string
  errorCode?: number
  sourceLocation?: SourceLocation
  secondarySourceLocations?: Array<SecondarySourceLocation>
}

/** JavaScript-facing wrappers mirroring the option structs. */
export interface CompilerSettings {
  stopAfter?: 'parsing' | undefined
  remappings?: `${string}=${string}`[] | undefined
  optimizer?: OptimizerSettings | undefined
  modelChecker?: ModelCheckerSettings | undefined
  metadata?: SettingsMetadata | undefined
  outputSelection?: import('./solc-settings').OutputSelection | undefined
  evmVersion?: EvmVersion
  viaIr?: boolean
  debug?: DebuggingSettings | undefined
  libraries?: Record<string, Record<string, string>> | undefined
}

export interface ContractBytecode {
  hex: `0x${string}`
  bytes: Uint8Array
}

export interface ContractState {
  name: string
  address?: `0x${string}` | null | undefined
  abi?: unknown | null | undefined
  sourcePath?: string
  sourceId?: number
  creationBytecode?: ContractBytecode | null | undefined
  deployedBytecode?: ContractBytecode | null | undefined
  metadata?: string | Record<string, unknown> | null | undefined
  userdoc?: Record<string, unknown> | null | undefined
  devdoc?: Record<string, unknown> | null | undefined
  storageLayout?: import('./solc-storage-layout').StorageLayout | null | undefined
  immutableReferences?: Record<string, { start: number; length: number }[]> | null | undefined
  methodIdentifiers?: Record<string, `0x${string}`> | null | undefined
  functionDebugData?: Record<string, FunctionDebugDataEntry> | null | undefined
  gasEstimates?: GasEstimates | null | undefined
  assembly?: string
  legacyAssembly?: Record<string, unknown> | null | undefined
  opcodes?: string
  ir?: string
  irOptimized?: string
  ewasm?: EwasmOutput | null | undefined
  creationSourceMap?: string | null | undefined
}

export interface DebuggingSettings {
  revertStrings?: RevertStrings
  debugInfo: Array<string>
}

export declare const enum EvmVersion {
  Byzantium = 'Byzantium',
  Constantinople = 'Constantinople',
  Petersburg = 'Petersburg',
  Istanbul = 'Istanbul',
  Berlin = 'Berlin',
  London = 'London',
  Paris = 'Paris',
  Shanghai = 'Shanghai',
  Cancun = 'Cancun',
  Prague = 'Prague'
}

export interface EwasmOutput {
  wast?: string | null | undefined
  wasm: string
}

export interface FunctionDebugDataEntry {
  entryPoint?: number | null | undefined
  id?: number | null | undefined
  parameterSlots?: number | null | undefined
  returnSlots?: number | null | undefined
}

export interface GasEstimates {
  creation: GasEstimatesCreation
  external: Record<string, string>
  internal: Record<string, string>
}

export interface GasEstimatesCreation {
  codeDepositCost: string
  executionCost: string
  totalCost: string
}

export interface ImmutableSlot {
  start: number
  length: number
}

export declare const enum ModelCheckerEngine {
  Bmc = 'Bmc',
  None = 'None'
}

export declare const enum ModelCheckerInvariant {
  Contract = 'Contract',
  Reentrancy = 'Reentrancy'
}

export declare const enum ModelCheckerInvariantKind {
  Reentrancy = 'Reentrancy',
  Contract = 'Contract'
}

export interface ModelCheckerSettings {
  contracts: Record<string, string[]> | undefined
  engine?: ModelCheckerEngine
  timeout?: number
  targets?: Array<ModelCheckerTarget>
  invariants?: Array<ModelCheckerInvariant>
  showUnproved?: boolean
  divModWithSlacks?: boolean
  solvers?: Array<ModelCheckerSolver>
  showUnsupported?: boolean
  showProvedSafe?: boolean
}

export declare const enum ModelCheckerSolver {
  Chc = 'Chc',
  Eld = 'Eld',
  Bmc = 'Bmc',
  AllZ3 = 'AllZ3',
  Cvc4 = 'Cvc4'
}

export declare const enum ModelCheckerTarget {
  Assert = 'Assert',
  Require = 'Require'
}

export interface OptimizerDetails {
  peephole?: boolean
  inliner?: boolean
  jumpdestRemover?: boolean
  orderLiterals?: boolean
  deduplicate?: boolean
  cse?: boolean
  constantOptimizer?: boolean
  yul?: boolean
  yulDetails?: YulDetails | undefined
  simpleCounterForLoopUncheckedIncrement?: boolean
}

export interface OptimizerSettings {
  enabled?: boolean
  runs?: number
  details?: OptimizerDetails | undefined
}

export interface ProjectPaths {
  root: string
  cache: string
  artifacts: string
  buildInfos: string
  sources: string
  tests: string
  scripts: string
  libraries: Array<string>
  includePaths: Array<string>
  allowedPaths: Array<string>
  virtualSources?: string
}

export declare const enum RevertStrings {
  Default = 'Default',
  Strip = 'Strip',
  Debug = 'Debug',
  VerboseDebug = 'VerboseDebug'
}

export interface SecondarySourceLocation {
  file?: string
  start?: number
  end?: number
  message?: string
}

export interface SettingsMetadata {
  useLiteralContent?: boolean
  bytecodeHash?: BytecodeHash
  cborMetadata?: boolean
}

export declare const enum SeverityLevel {
  Error = 'Error',
  Warning = 'Warning',
  Info = 'Info'
}

export declare const enum SolcLanguage {
  Solidity = 'Solidity',
  Yul = 'Yul'
}

export interface SourceLocation {
  file: string
  start: number
  end: number
}

export interface YulDetails {
  stackAllocation?: boolean
  optimizerSteps?: string
}

type WithPathKey<TPath, TValue> = TValue extends SourceArtifacts<infer _>
  ? SourceArtifacts<Extract<TPath, string>>
  : TValue;

type ReadonlyRecord<K extends PropertyKey, V> = Readonly<{
  [P in K]: WithPathKey<P, V>;
}>;

type ReadonlyPartialRecord<K extends PropertyKey, V> = Readonly<
  Partial<{ [P in K]: WithPathKey<P, V> }>
>;

type ArtifactMap<
  THasErrors extends boolean,
  TPaths extends readonly string[] | undefined
> = TPaths extends readonly string[]
  ? THasErrors extends false
    ? ReadonlyRecord<TPaths[number], SourceArtifacts>
    : ReadonlyPartialRecord<TPaths[number], SourceArtifacts>
  : never;

type ArtifactValue<
  THasErrors extends boolean,
  TPaths extends readonly string[] | undefined
> = TPaths extends undefined
  ? THasErrors extends false
    ? SourceArtifacts
    : SourceArtifacts | undefined
  : never;

/**
 * Place custom type/interface overrides here. The postbuild-dts script will
 * replace matching declarations in build/index.d.ts after every build.
 */

type ContractStateInput = { name: string } & Partial<
  Omit<ContractState, "name">
>;

type ContractStateKeys = keyof ContractState;

type MutableContractStateKeys = Exclude<ContractStateKeys, "name">;

type NormalizeValue<Value> = [Exclude<Value, undefined>] extends [never]
  ? undefined
  : Exclude<Value, undefined>;

type DefinedValue<Key extends MutableContractStateKeys> = NormalizeValue<
  ContractState[Key]
>;

export type ContractStateMap = Partial<{
  [Key in MutableContractStateKeys]: DefinedValue<Key>;
}>;

export type ContractSnapshot<
  Name extends string,
  Map extends ContractStateMap
> = {
  name: Name;
} & {
  [Key in MutableContractStateKeys]: Map extends { [P in Key]-?: infer Value }
    ? Value
    : undefined;
};

export type FieldValue<
  Map extends ContractStateMap,
  Key extends MutableContractStateKeys
> = Map extends { [P in Key]-?: infer Value }
  ? [Value] extends [never]
    ? undefined
    : Value
  : undefined;

type ExtractDefinedValue<
  Input extends ContractStateInput,
  Key extends MutableContractStateKeys
> = NormalizeValue<
  Input extends { [P in Key]-?: infer Value } ? Value : undefined
>;

type StateMapFromInput<Input extends ContractStateInput> = {
  [Key in MutableContractStateKeys as ExtractDefinedValue<
    Input,
    Key
  > extends never
    ? never
    : Key]: ExtractDefinedValue<Input, Key>;
};

type UpdateMap<
  Map extends ContractStateMap,
  Key extends MutableContractStateKeys,
  Value
> = [NormalizeValue<Value>] extends [never]
  ? Omit<Map, Key>
  : Omit<Map, Key> & { [P in Key]: NormalizeValue<Value> };

type BytecodeMapValue<Next> = Next extends undefined
  ? undefined
  : Next extends null
  ? null
  : ContractBytecode;

type DefaultContractState = ContractSnapshot<string, {}>;

type FullyDefinedMap = {
  [Key in MutableContractStateKeys]: DefinedValue<Key>;
};

type NameOf<State extends ContractSnapshot<string, ContractStateMap>> =
  State extends ContractSnapshot<infer Name, any> ? Name : string;

type MapOf<State extends ContractSnapshot<string, ContractStateMap>> =
  State extends ContractSnapshot<string, infer Map> ? Map : {};

type ContractStateSnapshot<State extends ContractStateInput> = ContractSnapshot<
  State["name"],
  StateMapFromInput<State>
>;

type ContractStateShape = ContractSnapshot<string, ContractStateMap>;

type SnapshotToInput<State extends ContractStateShape> = {
  name: NameOf<State>;
} & {
  [Key in MutableContractStateKeys]?: MapOf<State> extends {
    [P in Key]-?: infer Value;
  }
    ? Value | undefined
    : undefined;
};

type ContractBytecodeStateValue<
  Next extends Uint8Array | `0x${string}` | string | null | undefined
> = BytecodeMapValue<Next>;

type UpdateField<
  State extends ContractStateShape,
  Key extends MutableContractStateKeys,
  Value
> = ContractSnapshot<NameOf<State>, UpdateMap<MapOf<State>, Key, Value>>;

type ContractStateAllDefined = ContractSnapshot<string, FullyDefinedMap>;

export interface ContractConstructor {
  new <StateInput extends ContractStateInput>(state: StateInput): Contract<
    StateInput["name"],
    StateMapFromInput<StateInput>
  >;
  fromSolcContractOutput(
    name: string,
    contract: object | string
  ): Contract<string, FullyDefinedMap>;
  readonly prototype: Contract;
}

export declare const Contract: ContractConstructor;
